"""
Bitbucket Repository Operations Helper
"""

import aiohttp
import asyncio
import tempfile
import subprocess
import logging
import json
import base64
from typing import Dict, List, Optional, Any
from urllib.parse import urlparse
import os

from app.config import settings

logger = logging.getLogger(__name__)

class BitbucketHelper:
    """Helper class for Bitbucket repository operations"""
    
    def __init__(self):
        self.username = settings.BITBUCKET_USERNAME
        self.token = settings.BITBUCKET_TOKEN
        self.base_url = "https://api.bitbucket.org/2.0"
        
        # Create auth header
        auth_string = f"{self.username}:{self.token}"
        self.auth_header = base64.b64encode(auth_string.encode()).decode()
    
    async def clone_repository(self, repo_url: str, target_dir: str) -> Dict:
        """
        Clone Bitbucket repository to target directory
        
        Args:
            repo_url: Bitbucket repository URL
            target_dir: Directory to clone into
            
        Returns:
            Dictionary with clone result
        """
        try:
            # Parse repo URL to extract workspace and repo name
            parsed_url = urlparse(repo_url)
            path_parts = parsed_url.path.strip('/').split('/')
            
            if len(path_parts) < 2:
                raise ValueError("Invalid Bitbucket repository URL")
            
            workspace = path_parts[0]
            repo_name = path_parts[1].replace('.git', '')
            
            # Create authenticated clone URL
            clone_url = f"https://{self.username}:{self.token}@bitbucket.org/{workspace}/{repo_name}.git"
            
            # Clone repository
            cmd = ["git", "clone", clone_url, target_dir]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            
            logger.info(f"Successfully cloned {repo_url} to {target_dir}")
            
            return {
                "success": True,
                "workspace": workspace,
                "repo_name": repo_name,
                "clone_dir": target_dir
            }
            
        except subprocess.CalledProcessError as e:
            logger.error(f"Git clone failed: {e.stderr}")
            raise Exception(f"Failed to clone repository: {e.stderr}")
        except Exception as e:
            logger.error(f"Error cloning repository: {str(e)}")
            raise
    
    async def create_pull_request(
        self,
        workspace: str,
        repo_name: str,
        source_branch: str,
        target_branch: str = "main",
        title: str = "Automated Vulnerability Fixes",
        description: str = "Automated security vulnerability fixes generated by VulnFixer",
        fixes_applied: List[Dict] = None
    ) -> Dict:
        """
        Create a pull request in Bitbucket
        """
        try:
            # Format PR description with fix details
            if fixes_applied:
                description += "\n\n## Fixes Applied:\n"
                for fix in fixes_applied:
                    vuln = fix.get('vulnerability', {})
                    description += f"- **{vuln.get('name', 'Unknown')}** ({vuln.get('severity', 'Unknown')} severity)\n"
            
            pr_data = {
                "title": title,
                "description": description,
                "source": {
                    "branch": {
                        "name": source_branch
                    }
                },
                "destination": {
                    "branch": {
                        "name": target_branch
                    }
                },
                "close_source_branch": False,
                "reviewers": []  # Can be populated with team members
            }
            
            url = f"{self.base_url}/repositories/{workspace}/{repo_name}/pullrequests"
            
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    url,
                    headers={
                        "Authorization": f"Basic {self.auth_header}",
                        "Content-Type": "application/json"
                    },
                    json=pr_data
                ) as response:
                    if response.status == 201:
                        pr_data = await response.json()
                        pr_url = pr_data.get("links", {}).get("html", {}).get("href")
                        
                        logger.info(f"Created pull request: {pr_url}")
                        
                        return {
                            "success": True,
                            "pr_url": pr_url,
                            "pr_id": pr_data.get("id"),
                            "branch_name": source_branch
                        }
                    else:
                        error_text = await response.text()
                        logger.error(f"Failed to create PR: {response.status} - {error_text}")
                        raise Exception(f"Failed to create pull request: {error_text}")
        
        except Exception as e:
            logger.error(f"Error creating pull request: {str(e)}")
            raise
    
    async def push_changes(
        self,
        repo_dir: str,
        branch_name: str,
        commit_message: str,
        files_changed: List[str] = None
    ) -> Dict:
        """
        Push changes to Bitbucket repository
        """
        try:
            # Change to repo directory
            original_dir = os.getcwd()
            os.chdir(repo_dir)
            
            try:
                # Create new branch
                subprocess.run(["git", "checkout", "-b", branch_name], check=True, capture_output=True)
                
                # Add files
                if files_changed:
                    for file_path in files_changed:
                        subprocess.run(["git", "add", file_path], check=True, capture_output=True)
                else:
                    subprocess.run(["git", "add", "."], check=True, capture_output=True)
                
                # Check if there are changes to commit
                result = subprocess.run(["git", "diff", "--cached", "--quiet"], capture_output=True)
                if result.returncode != 0:  # There are changes
                    # Commit changes
                    subprocess.run(
                        ["git", "commit", "-m", commit_message],
                        check=True,
                        capture_output=True
                    )
                    
                    # Push to remote
                    subprocess.run(
                        ["git", "push", "origin", branch_name],
                        check=True,
                        capture_output=True
                    )
                    
                    return {
                        "success": True,
                        "branch_name": branch_name,
                        "message": "Changes pushed successfully"
                    }
                else:
                    return {
                        "success": False,
                        "message": "No changes to commit"
                    }
                    
            finally:
                os.chdir(original_dir)
                
        except subprocess.CalledProcessError as e:
            logger.error(f"Git operation failed: {e.stderr}")
            return {
                "success": False,
                "error": f"Git operation failed: {e.stderr.decode() if e.stderr else 'Unknown error'}"
            }
        except Exception as e:
            logger.error(f"Error pushing changes: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    async def get_repository_info(self, workspace: str, repo_name: str) -> Dict:
        """
        Get repository information from Bitbucket API
        """
        try:
            url = f"{self.base_url}/repositories/{workspace}/{repo_name}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    headers={"Authorization": f"Basic {self.auth_header}"}
                ) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        error_text = await response.text()
                        raise Exception(f"Failed to get repo info: {error_text}")
        
        except Exception as e:
            logger.error(f"Error getting repository info: {str(e)}")
            raise
    
    async def get_file_content(
        self,
        workspace: str,
        repo_name: str,
        file_path: str,
        branch: str = "main"
    ) -> str:
        """
        Get content of a specific file from Bitbucket repository
        """
        try:
            url = f"{self.base_url}/repositories/{workspace}/{repo_name}/src/{branch}/{file_path}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    headers={"Authorization": f"Basic {self.auth_header}"}
                ) as response:
                    if response.status == 200:
                        return await response.text()
                    else:
                        logger.warning(f"File {file_path} not found in repository")
                        return None
        
        except Exception as e:
            logger.error(f"Error getting file content: {str(e)}")
            return None
    
    async def list_repository_files(
        self,
        workspace: str,
        repo_name: str,
        path: str = "",
        branch: str = "main"
    ) -> List[Dict]:
        """
        List files in repository directory
        """
        try:
            url = f"{self.base_url}/repositories/{workspace}/{repo_name}/src/{branch}/{path}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    url,
                    headers={"Authorization": f"Basic {self.auth_header}"}
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get("values", [])
                    else:
                        return []
        
        except Exception as e:
            logger.error(f"Error listing repository files: {str(e)}")
            return []
    
    def parse_repo_url(self, repo_url: str) -> Dict:
        """
        Parse Bitbucket repository URL to extract components
        """
        try:
            parsed_url = urlparse(repo_url)
            path_parts = parsed_url.path.strip('/').split('/')
            
            if len(path_parts) < 2:
                raise ValueError("Invalid Bitbucket repository URL")
            
            workspace = path_parts[0]
            repo_name = path_parts[1].replace('.git', '')
            
            return {
                "workspace": workspace,
                "repo_name": repo_name,
                "full_name": f"{workspace}/{repo_name}"
            }
            
        except Exception as e:
            logger.error(f"Error parsing repository URL: {str(e)}")
            raise ValueError(f"Invalid Bitbucket repository URL: {repo_url}")

# Utility function for repository operations
async def process_bitbucket_repository(
    repo_url: str,
    fixes_to_apply: List[Dict],
    branch_name: str = None
) -> Dict:
    """
    Complete workflow for processing Bitbucket repository
    """
    helper = BitbucketHelper()
    
    try:
        # Parse repo URL
        repo_info = helper.parse_repo_url(repo_url)
        workspace = repo_info["workspace"]
        repo_name = repo_info["repo_name"]
        
        # Create temporary directory for cloning
        with tempfile.TemporaryDirectory() as temp_dir:
            # Clone repository
            clone_result = await helper.clone_repository(repo_url, temp_dir)
            
            if not clone_result["success"]:
                return clone_result
            
            # Apply fixes (this would be done by the vulnerability agent)
            files_changed = []
            for fix in fixes_to_apply:
                # Apply individual fixes and track changed files
                # Implementation depends on fix type
                pass
            
            # Generate branch name if not provided
            if not branch_name:
                import time
                branch_name = f"vulnfixer-fixes-{int(time.time())}"
            
            # Push changes
            push_result = await helper.push_changes(
                temp_dir,
                branch_name,
                f"Fix {len(fixes_to_apply)} security vulnerabilities",
                files_changed
            )
            
            if push_result["success"]:
                # Create pull request
                pr_result = await helper.create_pull_request(
                    workspace,
                    repo_name,
                    branch_name,
                    fixes_applied=fixes_to_apply
                )
                
                return {
                    "success": True,
                    "pr_url": pr_result["pr_url"],
                    "branch_name": branch_name,
                    "fixes_applied": len(fixes_to_apply)
                }
            else:
                return push_result
                
    except Exception as e:
        logger.error(f"Error processing Bitbucket repository: {str(e)}")
        return {
            "success": False,
            "error": str(e)
        }